#!/bin/bash
#
#
# 1st argument: project name
# 2nd argument: Tinker parameter file
#
tinkerdir=`grep "Tinker" Infos.dat | awk '{ print $2 }'`
templatedir=`grep "Template" Infos.dat | awk '{ print $2 }'`
retstereo=`grep "RetStereo" Infos.dat | awk '{ print $2 }'`
cavity=`grep "CavityFile" Infos.dat | awk '{ print $2 }'`
backb=`grep "BackBoneMD" Infos.dat | awk '{ print $2 }'`
radius=`grep "RadiusMD" Infos.dat | awk '{ print $2 }'`
origproj=`grep "Project" Infos.dat | awk '{ print $2 }'`
multchain=`grep "MultChain" Infos.dat | awk '{ print $2 }'`
diffchain=( $( grep "DiffChain" Infos.dat | awk '{ $1 =""; print }' ) )
lastres=( $( grep "LastRes" Infos.dat | awk '{ $1 =""; print }' ) )
startres=( $( grep "StartRes" Infos.dat | awk '{ print $2 }' ) ) 
version=`grep "Tk" Infos.dat | awk '{ print $3 }'`
Project=$1
xyzfile=$1.xyz
prm=$2
if [ -z $Project ]; then
   echo "Something wrong!"
   exit 0
fi
#
# I start writing $Project.key
#
echo "parameters $prm" > $Project.key
echo "" >> $Project.key
#
# Getting the retinal atoms in file retnum, and finding the 1st and last atom
#
awk '{ if ( $6 == 2012 || $6 == 2013 || $6 == 2014 ) print $0 }' $xyzfile > retnum
startret=`cat retnum | head -n 1 | awk '{ print $1 }'`
endret=`cat retnum | tail -n 1 | awk '{ print $1 }'`
#
# last-first plus one gives the number of retinal atoms
#
retatoms=$(($endret-$startret+1))
#
# retinal atoms + 5 QM lysine atoms + 9 MM lysine sidechain gives the total
# 5+9=14. When retinal is neutral. there are just 4 QM lysine atoms
#
if [[ $retstereo == "nAT" ]]; then
   lysqm=4
else
   lysqm=5 
fi
qmmmatoms=$(($retatoms+9+$lysqm))
echo "QMMM $qmmmatoms" >> $Project.key
#
# Cycling over the qmnums vector, which is created for VMD selection, by reading
# retnum. i=6 because the 5 QM lysine atoms will be added in the first 5 places.
# i=5 must be used for neutral retinal
#
i=$(($lysqm+1))
while read line; do
      numatom=`echo $line | awk '{ print $1 }'`
      qmnums[$i]=$numatom
      conn1=`echo $line | awk '{ print $7 }'`
#
# When the difference between the atom number numatom and the first field of connectivity
# is large, the C15 atom has been found. Its connectivity field is the lysine N3 number
#
      diff=$(($numatom-$conn1))
      if [[ $diff -gt 50 ]]; then
         lysine=$conn1
      fi
      i=$(($i+1))
done < retnum
#
# Storing the other QM atoms by relative position compared to lysine N3
# Cepsilon,N3, Hepsilon1, Hepsilon2 and nitrogen H, which is not there when retinal is neutral
#
qmnums[1]=$(($lysine-1))
qmnums[2]=$lysine
qmnums[3]=$(($lysine+7))
qmnums[4]=$(($lysine+8))
if [[ $retstereo != "nAT" ]]; then
   qmnums[5]=$(($lysine+9))
fi
#
# MM lysine atoms are calculated like before. Lysine N3 minus 4 is the Cbeta, and so on
# The QMMM section is written with ranges of atoms
#
echo "MM -$(($lysine-4)) $(($lysine-2))" >> $Project.key
echo "MM -$(($lysine+1)) $(($lysine+6))" >> $Project.key
#
# All the QM atoms stored before
#
echo "QM -${qmnums[1]} ${qmnums[2]}" >> $Project.key
echo "QM -${qmnums[3]} ${qmnums[$lysqm]}" >> $Project.key
echo "QM -$startret $endret" >> $Project.key
#
# tuttiatm reads the total number of atoms in the xyz file. Link atom generated by Tinker
# will have tuttiatm+1 as a number. * is for re-use the same key file after xyzedit
#
tuttiatm=`head -n 1 $xyzfile | awk '{ print $1 }'`
echo "*LA $(($tuttiatm+1))" >> $Project.key
#
# Cleaning up
#
rm retnum
#
# Creating the list of QM atoms to be used for VMD selection of the chromophore cavity
#
for ((i=1;i<=$(($lysqm));i=$(($i+1)))); do
    echo -n "${qmnums[$i]} " >> qmserials
done
#
# Asking the user for microiterations ON/OFF
#
answer=b
echo ""
while [[ $answer != y && $answer != n ]]; do
      echo " Do you want to activate microiterations? (y/n)"
      read answer
      echo ""
done
case $answer in
     y) microit=ON
     ;;
     n) microit=OFF
     ;;
esac
#
# Adding QM/MM keywords and parametrized charges for the lysine sidechains
#
case $version in
     4.2 | 5.1) 
     echo "QMMM-ELECTROSTATICS ESPF" >> $Project.key
     ;;
     6.2 | 6.3)
     echo " " >> $Project.key
esac


#echo "QMMM-ELECTROSTATICS ESPF" >> $Project.key
echo "QMMM-microiteration $microit" >> $Project.key
#
# Adding the charges. If retinal is neutral, different charges should be used
#
if [[ $retstereo == "nAT" ]]; then
   cp $templatedir/charges-neu charges
else
   cp $templatedir/charges .
fi
IFS=""
j=$(($lysine-10))
while read line; do
      echo $line | awk '{ sub($2,'"-$j"'); print $0 }' >> $Project.key
      j=$(($j+1))
done < charges
rm charges
#
# Creating the folder for VMD selection. If it is existing, back it up and creates a new one
#
if [[ -d vmdfiles ]]; then
   k=1
   while [[ -d $k.vmdfiles ]]; do
         k=$(($k+1))
   done
   mv vmdfiles $k.vmdfiles
fi
mkdir vmdfiles
cd vmdfiles/
#
# Copying the relevant files
# 
cp ../conversion/$Project.xyz .
cp ../conversion/$Project.seq .
cp ../$prm .
#
# Adding retinal to the seq file and converting the xyz file to PDB
#
echo "   Z     1  RET" >> $Project.seq
$tinkerdir/xyzpdb $Project.xyz << EOF
ALL
../$prm
EOF
#
# When the first residue is not 1, Tinker renumber it. The following fixes this problem
# 
#
firstnum=`grep '^ATOM' ../$origproj.pdb | head -n 1 | awk '{ print $6 }'`
if [[ $firstnum -gt 1 && $multchain == NO ]]; then
   shifter=`echo $startres-1 | bc`
   awk '{ if ( $1 != "HETATM" ) { newnum = $6 + '"$shifter"'}  else { newnum = $5}; printf("%3s\n", newnum) }' $Project.pdb > resnum
   cut -c1-22 $Project.pdb > testa
   cut -c28-106 $Project.pdb > coda
   paste -d" " testa resnum coda > numok_$Project.pdb
   mv $Project.pdb pretk_$Project.pdb
   mv numok_$Project.pdb $Project.pdb
   rm testa resnum coda
fi

#
# When the first residue is not 1 and more than 1 chain. The following fixes this problem
#
#
if [[ $firstnum -gt 1 && $multchain == YES ]]; then
   shifter=`echo $startres-1 | bc`
   awk '{ if ( $1 != "HETATM" ) { newnum = $6 + '"$shifter"'}  else { newnum = $5}; printf("%3s\n", newnum) }' $Project.pdb > resnum
   cut -c1-22 $Project.pdb > testa
   cut -c28-106 $Project.pdb > coda
   paste -d" " testa resnum coda > numok_$Project.pdb
   mv $Project.pdb pretk_$Project.pdb
   mv numok_$Project.pdb $Project.pdb
   rm testa resnum coda
   nchain=${#diffchain[*]}
   i=0
   for lette in {A..E}; do
       catene[$i]=$lette
       i=$(($i+1))
   done
   for ((i=0;$i<$nchain;i=$(($i+1)))); do
       curlastres=${lastres[$i]}
       curdiffchain=${diffchain[$i]}
       shifter2=$(($curlastres+$curdiffchain-$shifter))
       j=$(($i+1))
awk '{ if ( $1 ~ /HETATM/ ) {newnum = $5 + '"$shifter2"'} else if ( $1 != HETATM && $5 == "'"${catene[$j]}"'" ) { newnum = $6 + '"$shifter2"' } else {newnum = $6};  printf("%3s\n", newnum) }' $Project.pdb > resnum
#awk '{ if ( $1 != HETATM && $5 == "'"${catene[$j]}"'" ) { newnum = $6 + '"$shifter"' }  else { newnum = $6 }; printf("%3s\n", newnum) }' $Project.pdb > resnum
       cut -c1-22 $Project.pdb > testa
       cut -c28-106 $Project.pdb > coda
       paste -d" " testa resnum coda > numok_$Project.pdb
       mv $Project.pdb pretk_$Project.pdb
       mv numok_$Project.pdb $Project.pdb
       rm testa resnum coda
   done
fi

#
# When the first residue is 1 but with multiple chains, the following fixed it. 
#
#

if [[ $firstnum -eq 1 && $multchain == YES ]]; then
  nchain=${#diffchain[*]}
   i=0
   for lette in {A..E}; do
       catene[$i]=$lette
       i=$(($i+1))
   done
   for ((i=0;$i<$nchain;i=$(($i+1)))); do
       curlastres=${lastres[$i]}
       curdiffchain=${diffchain[$i]}
       shifter=$(($curlastres+$curdiffchain))
       j=$(($i+1))
       awk '{ if ( $1 ~ /HETATM/ ) {newnum = $5 + '"$shifter"'} else if ( $1 != HETATM && $5 == "'"${catene[$j]}"'" ) { newnum = $6 + '"$shifter"' } else {newnum = $6};  printf("%3s\n", newnum) }' $Project.pdb > resnum
#awk '{ if ( $1 != HETATM && $5 == "'"${catene[$j]}"'" ) { newnum = $6 + '"$shifter"' }  else { newnum = $6 }; printf("%3s\n", newnum) }' $Project.pdb > resnum
       cut -c1-22 $Project.pdb > testa
       cut -c28-106 $Project.pdb > coda
       paste -d" " testa resnum coda > numok_$Project.pdb
       mv $Project.pdb pretk_$Project.pdb
       mv numok_$Project.pdb $Project.pdb
       rm testa resnum coda
   done
fi

#
# Copying the required files into vmdfiles and running vmdsel.sh
# atom numbers are copied into active.key in the main folder
#
cp $templatedir/vmdsel.sh .
cp ../qmserials .
grep RET $Project.pdb | awk '{ print $2 }' >> qmserials
if [[ $cavity == YES ]]; then
   residline=`tr '\n' ' ' < ../cavity` 
   selection="resid $residline"
else
   selection="NO"
fi
###
### This section is obsolete as we have to fix the numbering and checking the cavity file before running vmdsel.sh       
###
###
# When multiple chains are present, the Tinker generated PDB has residue numbers restarting from 1 in each chain
# This section fixes this problem 
#
#if [[ $multchain == YES ]]; then
#   nchain=${#diffchain[*]}
#   i=0
#   for lette in {A..E}; do
#       catene[$i]=$lette
#       i=$(($i+1))
#   done
#   for ((i=0;$i<$nchain;i=$(($i+1)))); do 
#       curlastres=${lastres[$i]}
#       curdiffchain=${diffchain[$i]}
#       shifter=$(($curlastres+$curdiffchain))
#       j=$(($i+1))
#       awk '{ if ( $1 != HETATM && $5 == "'"${catene[$j]}"'" ) { newnum = $6 + '"$shifter"' }  else { newnum = $6 }; printf("%3s\n", newnum) }' $Project.pdb > resnum
#       cut -c1-22 $Project.pdb > testa
#       cut -c28-106 $Project.pdb > coda
#       paste -d" " testa resnum coda > numok_$Project.pdb
#       mv $Project.pdb pretk_$Project.pdb
#       mv numok_$Project.pdb $Project.pdb
#       rm testa resnum coda
#   done
#fi

./vmdsel.sh $Project $selection $backb $radius
cp qmmm.dat ../active.key
cd ..
rm qmserials
#
# VIM script to generate the ACTIVE $number style of Tinker key file
#
echo ":%s/ /\r/g" > activator.vim
echo ":%s/^/ACTIVE /" >> activator.vim
echo ":x" >> activator.vim
vim -es active.key < activator.vim
rm activator.vim
cat $Project.key active.key > temp.key
mv temp.key $Project.key
rm active.key
#
# Adding the QM atoms to the active atoms, at the bottom of the key file
# Using the same lines as the QMMM section
#
echo "ACTIVE -${qmnums[1]} ${qmnums[2]}" >> $Project.key
echo "ACTIVE -${qmnums[3]} ${qmnums[$lysqm]}" >> $Project.key
echo "ACTIVE -$startret $endret" >> $Project.key
echo "*ACTIVE $(($tuttiatm+1))" >> $Project.key
#
# Backing up the initial Tinker files. If tkstartfiles is existing it backs it up and create an empty folder
#
if [[ -d tkstartfiles ]]; then
   k=1
   while [[ -d $k.tkstartfiles ]]; do
         k=$(($k+1))
   done
   mv tkstartfiles $k.tkstartfiles
   rm $Project.input
fi
mkdir tkstartfiles
cp $Project.xyz tkstartfiles/
cp $Project.key tkstartfiles/
#
# xyzedit generates the Molcas input file and adds the link atom
#
case $version in
     4.2 | 5.1)
     echo "20" >> tinkerxyzedit.vim
     echo "1" >> tinkerxyzedit.vim
     ;;
     6.2 | 6.3)
     echo "21" >> tinkerxyzedit.vim
     echo "1" >> tinkerxyzedit.vim
esac

$tinkerdir/xyzedit $Project.xyz < tinkerxyzedit.vim
rm tinkerxyzedit.vim
#
# Preparing the final versions of the Tinker files, to be used in all the following QM/MM calculations
# 
mv $Project.xyz_2 $Project.xyz
sed -i "s/QMMM $qmmmatoms/QMMM $(($qmmmatoms+1))/; s/*LA/LA/; s/*ACTIVE/ACTIVE/" $Project.key
#
# VIM script for input modifications
#
echo ':%s/\.\.\.\.\.\./\.3-21G/' > qmmmlabel.vim
echo ':%s/\.3-21G\ \/\ MM/\.\.\.\.\.\.\ \/\ MM/' >> qmmmlabel.vim
echo ':/Seward' >> qmmmlabel.vim
echo ':.,$d' >> qmmmlabel.vim
echo ':x' >> qmmmlabel.vim
vim -es $Project.input < qmmmlabel.vim
rm qmmmlabel.vim
#
# Messages to the user
#
echo ""
echo " Tinker files ready! Proceeding to the QM/MM calculations"
echo ""

